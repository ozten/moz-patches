# HG changeset patch
# Parent 7abb56b3bbb7400d5387d53dfed35d0acf32eaca

diff --git a/browser/base/content/browser-identity.js b/browser/base/content/browser-identity.js
--- a/browser/base/content/browser-identity.js
+++ b/browser/base/content/browser-identity.js
@@ -21,43 +21,63 @@ function IdentityShim() {
   this.isLoaded = false;
 }
 
 IdentityShim.prototype = {
   init: function IdentityShim_init() {
     addMessageListener('identity-delegate-watch', this);
     addMessageListener('identity-delegate-request', this);
     addMessageListener('identity-delegate-logout', this);
+
+    addMessageListener('identity-delegate-signIn', this);
+    addMessageListener('identity-delegate-signOut', this);
+    addMessageListener('identity-delegate-createAccount', this);
     sendAsyncMessage('identity-delegate-loaded');
     logger.log('init().  sent identity-delegate-complete');
     this.isLoaded = true;
   },
 
   uninit: function IdentityShim_uninit() {
     if (this.isLoaded) {
       removeMessageListener('identity-delegate-watch', this);
       removeMessageListener('identity-delegate-request', this);
       removeMessageListener('identity-delegate-logout', this);
+
+      removeMessageListener('identity-delegate-signIn', this);
+      removeMessageListener('identity-delegate-signOut', this);
+      removeMessageListener('identity-delegate-createAccount', this);
       sendAsyncMessage('identity-delegate-complete', null);
       logger.log('uninit().  sent identity-delegate-complete');
       this.isLoaded = false;
     }
   },
 
   receiveMessage: function IdentityShim_receiveMessage(aMessage) {
+    let options = aMessage.json;
     switch (aMessage.name) {
       case 'identity-delegate-watch':
-        this.watch(aMessage.json);
+        this.watch(options);
         break;
       case 'identity-delegate-request':
-        this.request(aMessage.json);
+        this.request(options);
         break;
       case 'identity-delegate-logout':
-        this.logout(aMessage.json);
+        this.logout(options);
         break;
+
+      case 'identity-delegate-signIn':
+        this.signIn(options);
+        break;
+      case 'identity-delegate-signOut':
+        this.signOut(options);
+        break;
+      case 'identity-delegate-createAccount':
+        this.createAccount(options);
+        break;
+  
       default:
         logger.error("received unexpected message:", aMessage.name);
         break;
     }
   },
 
   _identityDoMethod: function IdentityShim__identityDoMethod(message) {
     sendAsyncMessage('identity-service-doMethod', message);
@@ -119,16 +139,82 @@ IdentityShim.prototype = {
       let BrowserID = content.wrappedJSObject.BrowserID;
       let callback = function() {
         this._identityDoMethod({method: 'logout', _internal: options._internal});
         this._close();
       }.bind(this);
 
       BrowserID.internal.logout(options.origin, callback);
     }
+  },
+
+  /*
+   * Sign in to browser
+   */
+  signIn: function IdentityShim_signIn(options) {
+    logger.log("signin with options", options);
+    let email = options.email;
+    let password = options.password;
+    let origin = options.origin;
+
+    logger.log("try to signin", email, "->", origin);
+    let stringifiedOptions = JSON.stringify(options);
+    let BrowserID = content.wrappedJSObject.BrowserID;
+
+    let callback = function(assertion, internalParams) {
+      internalParams = internalParams || {};
+      logger.log("got assertion");
+      this._identityDoMethod({
+        method: 'signIn',
+        assertion: assertion,
+        _internal: options._internal,
+        _internalParams: internalParams});
+    }.bind(this);
+
+    BrowserID.internal.signIn(email, password, origin, callback, stringifiedOptions);
+  },
+
+  /*
+   * Sign out of browser
+   */
+
+  signOut: function IdentityShim_signOut(options) {
+    logger.log("signout with options", options);
+    let BrowserID = content.wrappedJSObject.BrowserID;
+
+    let callback = function() {
+      this._identityDoMethod({method: 'signOut', _internal: options._internal});
+      this._close();
+    }
+
+    BrowserID.internal.signOut(options.origin);
+  },
+
+  /*
+   * Create user from browser
+   */
+  createAccount: function IdentityShim_createAccount(options) {
+    logger.log("create user with options", options);
+    let email = options.email;
+    let password = options.password;
+    let origin = options.origin;
+    let BrowserID = content.wrappedJSObject.BrowserID;
+
+    // XXX what about unverified here ...
+    let callback = function(assertion) {
+      this._identityDoMethod({
+        method: 'createAccount',
+        email: email,
+        origin: origin,
+        assertion: assertion,
+        success: success
+      });
+    }.bind(this);
+
+    BrowserID.internal.createAccount(email, password, callback);
   }
 };
 
 this.shim = null; 
 
 addEventListener('DOMContentLoaded', function(e) {
   content.addEventListener('load', function(e) {
     logger.log('content loaded');
diff --git a/browser/modules/SignInToWebsite.jsm b/browser/modules/SignInToWebsite.jsm
--- a/browser/modules/SignInToWebsite.jsm
+++ b/browser/modules/SignInToWebsite.jsm
@@ -63,25 +63,25 @@ function ResizeWatcher(iframe) {
 }
 
 ResizeWatcher.prototype = {
   start: function ResizeWatcher_start() {
     this.stop(); // just in case...
     let doc = this._iframe.contentDocument;
 
     this._mutationObserver = new this._iframe.contentWindow.MutationObserver(
-      function(mutations) { 
-        sizePanelToContent(this._iframe); 
+      function(mutations) {
+        sizePanelToContent(this._iframe);
       }.bind(this));
 
     // Observe anything that causes the size to change.
     let config = {
-      attributes: true, 
-      characterData: true, 
-      childList: true, 
+      attributes: true,
+      characterData: true,
+      childList: true,
       subtree: true
     };
 
     this._mutationObserver.observe(doc, config);
 
     // and since this may be setup after the load event has fired we do an
     // initial resize now.
     sizePanelToContent(this._iframe);
@@ -184,16 +184,17 @@ HostFrame.prototype = {
   },
 
   /*
    * create an iframe and insert it into aOptions.  If showUI is
    * true, attach the iframe to a xul panel in the popup notification.
    * Otherwise attach to a hidden document.
    */
   _createIframe: function HostFrame_createIframe(aOptions) {
+    logger.log("options:", aOptions);
     let srcURI = aOptions.showUI ? kIdentityScreen : kIdentityFrame;
     logger.log('showUI is', aOptions.showUI, 'so iframe src =', srcURI);
 
     let hiddenDoc = Services.appShell.hiddenDOMWindow.document;
     this._iframe = hiddenDoc.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');
 
     this._iframe.setAttribute('mozbrowser', true);
     this._iframe.setAttribute('mozframetype', 'content');
@@ -204,16 +205,17 @@ HostFrame.prototype = {
 
     // implement a dynamic resize watcher a la Social API
     this._iframe.style.height = "440px";
     this._iframe.style.width = "300px";
 
     aOptions.iframe = this._iframe;
 
     if (aOptions.showUI) {
+      logger.log("show ui");
       // synchronous, so we can call _injectShim below with no race condition
       requestUI(aOptions);
       this._resizeWatcher = new ResizeWatcher(this._iframe);
     } else {
       hiddenDoc.documentElement.appendChild(this._iframe);
     }
     this._injectShim(this._iframe);
   },
@@ -315,23 +317,31 @@ Pipe.prototype = {
 
 this.SignInToWebsiteUX = {
   init: function SignInToWebsiteUX_init() {
     this.contexts = {};
     Services.obs.addObserver(this, 'identity-controller-watch', false);
     Services.obs.addObserver(this, 'identity-controller-request', false);
     Services.obs.addObserver(this, 'identity-controller-logout', false);
     Services.obs.addObserver(this, 'identity-controller-canceled', false);
+
+    Services.obs.addObserver(this, 'identity-controller-signIn', false);
+    Services.obs.addObserver(this, 'identity-controller-signOut', false);
+    Services.obs.addObserver(this, 'identity-controller-createAccount', false);
   },
 
   uninit: function SignInToWebsiteUX_uninit() {
     Services.obs.removeObserver(this, 'identity-controller-watch');
     Services.obs.removeObserver(this, 'identity-controller-request');
     Services.obs.removeObserver(this, 'identity-controller-logout');
     Services.obs.removeObserver(this, 'identity-controller-canceled');
+
+    Services.obs.addObserver(this, 'identity-controller-signIn');
+    Services.obs.addObserver(this, 'identity-controller-signOut');
+    Services.obs.addObserver(this, 'identity-controller-createAccount');
   },
 
   observe: function SignInToWebsiteUX_observe(aSubject, aTopic, aData) {
     logger.log('controller observed:', aTopic);
     // XXX need to detect page unload of any of our flows
     // XXX we get strings from xul, and objects from elsewhere
     let rpOptions = {};
     if (aSubject) {
@@ -342,17 +352,17 @@ this.SignInToWebsiteUX = {
       }
     }
     if (!rpOptions.id) {
       logger.error('Got a message with no RP id');
       return;
     }
 
     let rpId = rpOptions.id;
-    let UI = getUIForWindowID(rpId);
+    //let UI = getUIForWindowID(rpId);
 
     let options = {
       id: rpOptions.id,
       rpOptions: rpOptions
     };
 
     switch (aTopic) {
       case 'identity-controller-watch':
@@ -362,16 +372,28 @@ this.SignInToWebsiteUX = {
       case 'identity-controller-request':
         this.doRequest(options);
         break;
 
       case 'identity-controller-logout':
         this.doLogout(options);
         break;
 
+      case 'identity-controller-signIn':
+        this.doSignIn(options);
+        break;
+
+      case 'identity-controller-signOut':
+        this.doSignOut(options);
+        break;
+
+      case 'identity-controller-createAccount':
+        this.doCreateAccount(options);
+        break;
+
       default:
         logger.error('SignInToWebsiteUX', 'Unknown observer notification:', aTopic);
         break;
     }
   },
 
   serviceDoMethod: function SignInToWebsiteUX_doMethod(aMessage, aId) {
     logger.log('serviceDoMethod received:', aMessage);
@@ -391,16 +413,28 @@ this.SignInToWebsiteUX = {
       case 'logout':
         IdentityService.doLogout(aId);
         break;
 
       case 'cancel':
         IdentityService.doCancel(aId);
         break;
 
+      case 'signIn':
+        IdentityService.doSignIn(aId, aMessage.assertion);
+        break;
+
+      case 'signOut':
+        IdentityService.doSignOut(aId);
+        break;
+
+      case 'createAccount':
+        IdentityService.doCreateAccount(aId, aMessage.assertion);
+        break;
+
       default:
         logger.error('Unknown identity method: ' + aMessage.method);
         break;
     }
   },
 
   cleanUp: function SignInToWebsiteUX_cleanUp(aId) {
     let context = this.contexts[aId];
@@ -448,10 +482,30 @@ this.SignInToWebsiteUX = {
     aOptions.showUI = true;
     this.delegate(aOptions);
   },
 
   doLogout: function SignInToWebsiteUX_doLogout(aOptions) {
     aOptions.message = 'identity-delegate-logout';
     aOptions.showUI = false;
     this.delegate(aOptions);
-  }
+  },
+
+  doSignIn: function SignInToWebsiteUX_doSignIn(aOptions) {
+    logger.log("delegating signin:" , aOptions);
+    aOptions.message = 'identity-delegate-signIn';
+    aOptions.showUI = false;
+    this.delegate(aOptions);
+  },
+
+  doSignOut: function SignInToWebsiteUX_doSignOut(aOptions) {
+    aOptions.message = 'identity-delegate-signOut';
+    aOptions.showUI = false;
+    this.delegate(aOptions);
+  },
+
+  doCreateAccount: function SignInToWebsiteUX_doCreateAccount(aOptions) {
+    aOptions.message = 'identity-delegate-createAccount';
+    aOptions.showUI = false;
+    this.delegate(aOptions);
+  },
+
 };
diff --git a/toolkit/identity/MinimalIdentity.jsm b/toolkit/identity/MinimalIdentity.jsm
--- a/toolkit/identity/MinimalIdentity.jsm
+++ b/toolkit/identity/MinimalIdentity.jsm
@@ -144,16 +144,64 @@ IDService.prototype = {
    */
   logout: function IDService_logout(aRpCallerId) {
     let rp = this._rpFlows[aRpCallerId];
 
     let options = makeMessageObject(rp);
     Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-logout", null);
   },
 
+  /**
+   * signIn to browser; callback with assertion on success or null
+   */
+  signIn: function IDService_signIn(aEmail, aPassword, aOrigin, aCallback) {
+    let id = getRandomId();
+    let rp = {
+      id: id,
+      origin: aOrigin,
+      onSignIn: aCallback
+    };
+    this._rpFlows[id] = rp;
+
+    let options = {
+      id: id,
+      email: aEmail,
+      password: aPassword
+    };
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-signIn", null);
+  },
+
+  signOut: function IDService_signOut(aRpCallerId, aCallback) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.error("No flow with id", aRpCallerId);
+    }
+    rp.onSignOut = aCallback;
+    let options = makeMessageObject(rp);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-signOut", null);
+  },
+
+  createAccount: function IDService_createAccount(aEmail, aPassword, aOrigin, aCallback) {
+    let id = getRandomId();
+    let rp = {
+      id: id,
+      email: aEmail,
+      origin: aOrigin,
+      onCreateAccount: aCallback
+    };
+    this._rpFlows[id] = rp;
+    let options = {
+      id: id,
+      origin: aOrigin,
+      email: aEmail,
+      password: aPassword
+    };
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-createAccount", null);
+  },
+
   /*
    * once the UI-and-display-logic components have received
    * notifications, they call back with direct invocation of the
    * following functions (doLogin, doLogout, or doReady)
    */
 
   doLogin: function IDService_doLogin(aRpCallerId, aAssertion, aInternalParams) {
     let rp = this._rpFlows[aRpCallerId];
@@ -190,16 +238,47 @@ IDService.prototype = {
     if (!rp) {
       logger.error("WARNING: doCancel found no rp for callerId ", aRpCallerId);
       return;
     }
 
     rp.doCancel();
   },
 
+  doSignIn: function IDService_doSignIn(aRpCallerId, aAssertion, aInternalParams) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.error("no flow for id", aRpCallerId);
+    }
+    logger.log("signed in with assertion", aAssertion);
+    if (typeof rp.onSignIn === 'function') {
+      rp.onSignIn(aAssertion, aInternalParams);
+    }
+  },
+
+  doSignOut: function IDService_doSignOut(aRpCallerId) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (rp) {
+      if (typeof rp.onSignOut === 'function') {
+        rp.onSignOut(true);
+      }
+      delete(this._rpFlows[aRpCallerId]);
+    }
+  },
+
+  doCreateAccount: function IDService_doCreateAccount(aRpCallerId, aAssertion) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (rp) {
+      if (typeof rp.onCreateAccount === 'function') {
+        rp.onCreateAccount(aAssertion);
+      }
+      delete(this._rpFlows[aRpCallerId]);
+    }
+  },
+
   /**
    * IDP functions are taken care of by the dialog.  The DOM should never
    * be calling these methods on this service.  So if it does, use the 
    * logger.error function to give a stack trace.
    */
 
   beginProvisioning: function IDService_beginProvisioning(context) {
     logger.error("Not implemented");
