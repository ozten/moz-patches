# HG changeset patch
# Parent eecc5a95ccd3cd42f11db0f8e797b7d9cdff906e

diff --git a/browser/modules/SignInToWebsite.jsm b/browser/modules/SignInToWebsite.jsm
--- a/browser/modules/SignInToWebsite.jsm
+++ b/browser/modules/SignInToWebsite.jsm
@@ -83,23 +83,33 @@ this.SignInToWebsiteUX = {
     let mainAction = {
       label: chromeWin.gNavigatorBundle.getString("identity.next.label"),
       accessKey: chromeWin.gNavigatorBundle.getString("identity.next.accessKey"),
       callback: function() {}, // required
     };
     let options = {
       identity: {
         origin: aOptions.origin,
+        rpId: aOptions.rpId
       },
     };
     let secondaryActions = [];
 
     // add some extra properties to the notification to store some identity-related state
-    for (let opt in aOptions) {
-      options.identity[opt] = aOptions[opt];
+    if (IdentityService.RP["_rpFlows"][options.identity.rpId]) {
+      var rpOptions = IdentityService.RP["_rpFlows"][options.identity.rpId];
+      for (let opt in aOptions) {
+        rpOptions[opt] = aOptions[opt];
+      }
+    } else {
+      dump(JSON.stringify(IdentityService.RP["_rpFlows"]));
+
+    dump("\nAOK options=" + JSON.stringify(options) + "\n");
+
+      dump("AOK ERROR, OUCH, NO IdentityService.RP[_rpFlows][options.identity.rpId]");
     }
     log("requestLogin: rpId: ", options.identity.rpId);
 
     chromeWin.PopupNotifications.show(browserEl, "identity-request", message,
                                       "identity-notification-icon", mainAction,
                                       [], options);
   },
 
@@ -110,17 +120,17 @@ this.SignInToWebsiteUX = {
     return IdentityService.RP.getIdentitiesForSite(aOrigin);
   },
 
   /**
    * User chose a new or existing identity from the doorhanger after a request() call
    */
   selectIdentity: function SignInToWebsiteUX_selectIdentity(aRpId, aIdentity) {
     log("selectIdentity: rpId: ", aRpId, " identity: ", aIdentity);
-    IdentityService.selectIdentity(aRpId, aIdentity);
+    IdentityService.selectIdentity(aRpId, aIdentity, IdentityService.RP["_rpFlows"][aRpId]);
   },
 
   // Private
 
   /**
    * Return the chrome window and <browser> for the given outer window ID.
    */
   _getUIForWindowID: function(aWindowID) {
diff --git a/dom/identity/DOMIdentity.jsm b/dom/identity/DOMIdentity.jsm
--- a/dom/identity/DOMIdentity.jsm
+++ b/dom/identity/DOMIdentity.jsm
@@ -216,16 +216,31 @@ this.DOMIdentity = {
 
   // Private.
   _init: function DOMIdentity__init() {
     Services.ww.registerNotification(this);
     Services.obs.addObserver(this, "xpcom-shutdown", false);
     this._subscribeListeners();
   },
 
+  _configureMessages: function DOMIdentity__configureMessages(aWindow, aRegister) {
+    if (!aWindow.messageManager) {
+      log("No aWindow.messageManager... bailing\n");
+      return;
+    }
+
+
+    let func = aWindow.messageManager[aRegister ? "addMessageListener"
+                                                : "removeMessageListener"];
+
+    for (let message of this.messages) {
+      func.call(aWindow.messageManager, message, this);
+    }
+  },
+
   _subscribeListeners: function DOMIdentity__subscribeListeners() {
     if (!ppmm) return;
     for (let message of this.messages) {
       ppmm.addMessageListener(message, this);
     }
   },
 
   _unsubscribeListeners: function DOMIdentity__unsubscribeListeners() {
diff --git a/toolkit/identity/Identity.jsm b/toolkit/identity/Identity.jsm
--- a/toolkit/identity/Identity.jsm
+++ b/toolkit/identity/Identity.jsm
@@ -113,17 +113,17 @@ IDService.prototype = {
    *
    * @param aRPId
    *        (integer) the id of the doc object obtained in .watch() and
    *                  passed to the UX component.
    *
    * @param aIdentity
    *        (string) the email chosen for login
    */
-  selectIdentity: function selectIdentity(aRPId, aIdentity) {
+  selectIdentity: function selectIdentity(aRPId, aIdentity, aOptions) {
     log("selectIdentity: RP id:", aRPId, "identity:", aIdentity);
 
     // Get the RP that was stored when watch() was invoked.
     let rp = this.RP._rpFlows[aRPId];
     if (!rp) {
       reportError("selectIdentity", "Invalid RP id: ", aRPId);
       return;
     }
@@ -131,17 +131,27 @@ IDService.prototype = {
     // It's possible that we are in the process of provisioning an
     // identity.
     let provId = rp.provId;
 
     let rpLoginOptions = {
       loggedInUser: aIdentity,
       origin: rp.origin
     };
+    log(rpLoginOptions);
+    for (let opt in aOptions) {
+      if (!! aOptions[opt]) {
+        dump("AOK setting " + opt + "=" + aOptions[opt] + "\n");
+        rpLoginOptions[opt] = aOptions[opt];
+      }
+
+    }
     log("selectIdentity: provId:", provId, "origin:", rp.origin);
+    dump("AOK Identity.jsm rpLoginOptions are\n");
+    dump(JSON.stringify(rpLoginOptions) + "\n");
 
     // Once we have a cert, and once the user is authenticated with the
     // IdP, we can generate an assertion and deliver it to the doc.
     let self = this;
     this.RP._generateAssertion(rp.origin, aIdentity, function hadReadyAssertion(err, assertion) {
       if (!err && assertion) {
         self.RP._doLogin(rp, rpLoginOptions, assertion);
         return;
@@ -154,53 +164,67 @@ IDService.prototype = {
           rp.doError(err);
           return;
         }
 
         // The idpParams tell us where to go to provision and authenticate
         // the identity.
         self.IDP._provisionIdentity(aIdentity, idpParams, provId, function gotID(err, aProvId) {
 
+
+          log("AOK aProvId");
+          log(aProvId);
+          log("AOK _provisionFlows");
+          log(self.IDP._provisionFlows);
+          log("AOK _provisionFlows[aProvId]");
+          log(self.IDP._provisionFlows[aProvId]);
+          log("AOK aRPId");
+          log(aRPId);
+
           // Provision identity may have created a new provision flow
           // for us.  To make it easier to relate provision flows with
           // RP callers, we cross index the two here.
           rp.provId = aProvId;
           self.IDP._provisionFlows[aProvId].rpId = aRPId;
 
           // At this point, we already have a cert.  If the user is also
           // already authenticated with the IdP, then we can try again
           // to generate an assertion and login.
           if (err) {
             // We are not authenticated.  If we have already tried to
             // authenticate and failed, then this is a "hard fail" and
             // we give up.  Otherwise we try to authenticate with the
             // IdP.
-
+            log("AOK error, not authenticated");
+            log(err);
             if (self.IDP._provisionFlows[aProvId].didAuthentication) {
+              log("AOK didAuthentication, cleaning up");
               self.IDP._cleanUpProvisionFlow(aProvId);
               self.RP._cleanUpProvisionFlow(aRPId, aProvId);
               log("ERROR: selectIdentity: authentication hard fail");
               rp.doError("Authentication fail.");
               return;
             }
             // Try to authenticate with the IdP.  Note that we do
             // not clean up the provision flow here.  We will continue
             // to use it.
-            self.IDP._doAuthentication(aProvId, idpParams);
+            self.IDP._doAuthentication(aProvId, idpParams, rpLoginOptions);
             return;
           }
 
           // Provisioning flows end when a certificate has been registered.
           // Thus IdentityProvider's registerCertificate() cleans up the
           // current provisioning flow.  We only do this here on error.
           self.RP._generateAssertion(rp.origin, aIdentity, function gotAssertion(err, assertion) {
             if (err) {
               rp.doError(err);
               return;
             }
+            log("AOK Identity.jsm looking for email - ");
+            log(rpLoginOptions);
             self.RP._doLogin(rp, rpLoginOptions, assertion);
             self.RP._cleanUpProvisionFlow(aRPId, aProvId);
             return;
           });
         });
       });
     });
   },
@@ -246,22 +270,25 @@ IDService.prototype = {
    *        (string) (optional) Protocol to use.  Default is https.
    *                 This is necessary because we are unable to test
    *                 https.
    *
    * @param aCallback
    *
    */
   _fetchWellKnownFile: function _fetchWellKnownFile(aDomain, aCallback, aScheme='https') {
+    dump("AOK fetching well known \n");
     if (Services.prefs.getPrefType(PERSONA_FALLBACK) != Ci.nsIPrefBranch.PREF_STRING) {
       return aCallback("Error: Bad persona fallback preference");
     }
     let personaBaseUrl = Services.prefs.getCharPref(PERSONA_FALLBACK);
     let url = personaBaseUrl + '/wsapi/discovery?domain=' + aDomain;
 
+    log(url);
+
     // this appears to be a more successful way to get at xmlhttprequest (which supposedly will close with a window
     let req = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"]
                 .createInstance(Ci.nsIXMLHttpRequest);
 
     // XXX bug 769865 gracefully handle being off-line
     // XXX bug 769866 decide on how to handle redirects
     req.open("GET", url, true);
     req.responseType = "json";
@@ -269,16 +296,19 @@ IDService.prototype = {
     req.onload = function _fetchWellKnownFile_onload() {
       if (req.status < 200 || req.status >= 400) {
         log("_fetchWellKnownFile", url, ": server returned status:", req.status);
         return aCallback("Error");
       }
       try {
         let idpParams = req.response;
 
+        log("AOK callback ");
+        log(idpParams);
+
         // Verify that the IdP returned a valid configuration
         if (! (idpParams.provisioning &&
             idpParams.authentication &&
             idpParams['public-key'])) {
           let errStr= "Invalid well-known file from: " + aDomain;
           log("_fetchWellKnownFile:", errStr);
           return aCallback(errStr);
         }
diff --git a/toolkit/identity/IdentityProvider.jsm b/toolkit/identity/IdentityProvider.jsm
--- a/toolkit/identity/IdentityProvider.jsm
+++ b/toolkit/identity/IdentityProvider.jsm
@@ -37,16 +37,17 @@ function IdentityProviderService() {
                                     "resource://gre/modules/identity/IdentityStore.jsm",
                                     "IdentityStore");
 
   this.reset();
 }
 
 IdentityProviderService.prototype = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
+  _sandboxConfigured: false,
 
   observe: function observe(aSubject, aTopic, aData) {
     switch (aTopic) {
       case "quit-application-granted":
         Services.obs.removeObserver(this, "quit-application-granted");
         this.shutdown();
         break;
     }
@@ -79,16 +80,22 @@ IdentityProviderService.prototype = {
     if (typeof aErrBack === 'function') {
       aErrBack(err);
     }
   },
 
   shutdown: function RP_shutdown() {
     this.reset();
 
+    if (this._sandboxConfigured) {
+      // Tear down message manager listening on the hidden window
+      Cu.import("resource://gre/modules/DOMIdentity.jsm");
+      DOMIdentity._configureMessages(Services.appShell.hiddenDOMWindow, false);
+      this._sandboxConfigured = false;
+    }
 
     Services.obs.removeObserver(this, "quit-application-granted");
   },
 
   get securityLevel() {
     return 1;
   },
 
@@ -294,24 +301,44 @@ IdentityProviderService.prototype = {
    * Begin the authentication process with an IdP
    *
    * @param aProvId
    *        (int) the identifier of the provisioning flow which failed
    *
    * @param aCallback
    *        (function) to invoke upon completion, with
    *                   first-positional-param error.
+   * @param aOptions
+   *        (object) options for authentication dialog
    */
-  _doAuthentication: function _doAuthentication(aProvId, aIDPParams) {
+  _doAuthentication: function _doAuthentication(aProvId, aIDPParams, aOptions) {
     log("_doAuthentication: provId:", aProvId, "idpParams:", aIDPParams);
     // create an authentication caller and its identifier AuthId
     // stash aIdentity, idpparams, and callback in it.
 
+    var whitelist = [
+      'backgroundColor',
+      'origin',
+      'privacyPolicy',
+      'returnTo',
+      'siteLogo',
+      'siteName',
+      'termsOfService'
+    ];
+
+    var rpLoginOptions = [];
+    for (let opt in aOptions) {
+      if (whitelist.indexOf(opt) !== -1) {
+        rpLoginOptions.push([opt] + '=' + encodeURIComponent(aOptions[opt]));
+      }
+    }
+
     // extract authentication URL from idpParams
-    let authPath = aIDPParams.idpParams.authentication;
+    let authPath = aIDPParams.idpParams.authentication +
+      '?' + rpLoginOptions.join('&');
     let authURI = Services.io.newURI("https://" + aIDPParams.domain, null, null).resolve(authPath);
 
     // beginAuthenticationFlow causes the "identity-auth" topic to be
     // observed.  Since it's sending a notification to the DOM, there's
     // no callback.  We wait for the DOM to trigger the next phase of
     // provisioning.
     this._beginAuthenticationFlow(aProvId, authURI);
 
@@ -430,16 +457,23 @@ IdentityProviderService.prototype = {
 
   /**
    * Load the provisioning URL in a hidden frame to start the provisioning
    * process.
    */
   _createProvisioningSandbox: function _createProvisioningSandbox(aURL, aCallback) {
     log("_createProvisioningSandbox:", aURL);
 
+    if (!this._sandboxConfigured) {
+      // Configure message manager listening on the hidden window
+      Cu.import("resource://gre/modules/DOMIdentity.jsm");
+      DOMIdentity._configureMessages(Services.appShell.hiddenDOMWindow, true);
+      this._sandboxConfigured = true;
+    }
+
     new Sandbox(aURL, aCallback);
   },
 
   /**
    * Load the authentication UI to start the authentication process.
    */
   _beginAuthenticationFlow: function _beginAuthenticationFlow(aProvId, aURL) {
     log("_beginAuthenticationFlow:", aProvId, aURL);
diff --git a/toolkit/identity/IdentityStore.jsm b/toolkit/identity/IdentityStore.jsm
--- a/toolkit/identity/IdentityStore.jsm
+++ b/toolkit/identity/IdentityStore.jsm
@@ -56,16 +56,19 @@ IDServiceStore.prototype = {
    *        (boolean) whether or not the user is logged in
    *
    * @param aEmail
    *        (email) the email address the user is logged in with,
    *                or, if not logged in, the default email for that origin.
    */
   setLoginState: function setLoginState(aOrigin, aState, aEmail) {
     if (aState && !aEmail) {
+      dump('AOK aState=' + JSON.stringify(aState) + "\n");
+      dump(JSON.stringify(aEmail) + "\n");
+      dump(new Error('ouch').stack);
       throw "isLoggedIn cannot be set to true without an email";
     }
     return this._loginStates[aOrigin] = {isLoggedIn: aState, email: aEmail};
   },
   getLoginState: function getLoginState(aOrigin) {
     return aOrigin in this._loginStates ? this._loginStates[aOrigin] : null;
   },
   clearLoginState: function clearLoginState(aOrigin) {
diff --git a/toolkit/identity/RelyingParty.jsm b/toolkit/identity/RelyingParty.jsm
--- a/toolkit/identity/RelyingParty.jsm
+++ b/toolkit/identity/RelyingParty.jsm
@@ -139,16 +139,18 @@ IdentityRelyingParty.prototype = {
    * on login
    *
    * Note that this calls _getAssertion
    */
   _doLogin: function _doLogin(aRpCaller, aOptions, aAssertion) {
     log("_doLogin: rpId:", aRpCaller.id, "origin:", aOptions.origin);
 
     let loginWithAssertion = function loginWithAssertion(assertion) {
+      log(aOptions);
+      log("AOK loggedInUser" + aOptions.loggedInUser);
       this._store.setLoginState(aOptions.origin, true, aOptions.loggedInUser);
       this._notifyLoginStateChanged(aRpCaller.id, aOptions.loggedInUser);
       aRpCaller.doLogin(assertion);
       aRpCaller.doReady();
     }.bind(this);
 
     if (aAssertion) {
       loginWithAssertion(aAssertion);
diff --git a/toolkit/identity/Sandbox.jsm b/toolkit/identity/Sandbox.jsm
--- a/toolkit/identity/Sandbox.jsm
+++ b/toolkit/identity/Sandbox.jsm
@@ -94,18 +94,19 @@ this.Sandbox.prototype = {
 
     // Stop about:blank from being loaded.
     docShell.stop(Ci.nsIWebNavigation.STOP_NETWORK);
 
     // Disable some types of content
     docShell.allowAuth = false;
     docShell.allowPlugins = false;
     docShell.allowImages = false;
-    docShell.allowMedia = false;
     docShell.allowWindowControl = false;
+    // TODO: disable media (bug 759964)
+    // docShell.allowMedia = false;
 
     // Disable stylesheet loading since the document is not visible.
     let markupDocViewer = docShell.contentViewer
                                   .QueryInterface(Ci.nsIMarkupDocumentViewer);
     markupDocViewer.authorStyleDisabled = true;
 
     // Set instance properties.
     this._frame = frame;
