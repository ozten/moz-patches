# HG changeset patch
# Parent a71dcb491f18156474923cb7e5786d6177f33181

diff --git a/dom/media/PeerConnection.js b/dom/media/PeerConnection.js
--- a/dom/media/PeerConnection.js
+++ b/dom/media/PeerConnection.js
@@ -3,16 +3,18 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/PopupNotifications.jsm");
+Cu.import('resource://gre/modules/identity/RTCIdentity.jsm');
 
 const PC_CONTRACT = "@mozilla.org/dom/peerconnection;1";
 const PC_ICE_CONTRACT = "@mozilla.org/dom/rtcicecandidate;1";
 const PC_SESSION_CONTRACT = "@mozilla.org/dom/rtcsessiondescription;1";
 const PC_MANAGER_CONTRACT = "@mozilla.org/dom/peerconnectionmanager;1";
 const PC_ICEEVENT_CONTRACT = "@mozilla.org/dom/rtcpeerconnectioniceevent;1";
 const MSEVENT_CONTRACT = "@mozilla.org/dom/mediastreamevent;1";
 const DCEVENT_CONTRACT = "@mozilla.org/dom/datachannelevent;1";
@@ -22,16 +24,17 @@ const PC_ICE_CID = Components.ID("{02b99
 const PC_SESSION_CID = Components.ID("{1775081b-b62d-4954-8ffe-a067bbf508a7}");
 const PC_MANAGER_CID = Components.ID("{7293e901-2be3-4c02-b4bd-cbef6fc24f78}");
 const PC_ICEEVENT_CID = Components.ID("{b9cd25a7-9859-4f9e-8f84-ef5181ff36c0}");
 const MSEVENT_CID = Components.ID("{a722a8a9-2290-4e99-a5ed-07b504292d08}");
 const DCEVENT_CID = Components.ID("{d5ed7fbf-01a8-4b18-af6c-861cf2aac920}");
 
 // Global list of PeerConnection objects, so they can be cleaned up when
 // a page is torn down. (Maps inner window ID to an array of PC objects).
+//
 function GlobalPCList() {
   this._list = [];
   this._networkdown = false; // XXX Need to query current state somehow
   Services.obs.addObserver(this, "inner-window-destroyed", true);
   Services.obs.addObserver(this, "profile-change-net-teardown", true);
   Services.obs.addObserver(this, "network:offline-about-to-go-offline", true);
   Services.obs.addObserver(this, "network:offline-status-changed", true);
 }
@@ -234,21 +237,24 @@ function RTCPeerConnection() {
   this._pc = null;
   this._observer = null;
   this._closed = false;
 
   this._onCreateOfferSuccess = null;
   this._onCreateOfferFailure = null;
   this._onCreateAnswerSuccess = null;
   this._onCreateAnswerFailure = null;
+  this._onIdentityAssertionSuccess = null;
 
   this._pendingType = null;
   this._localType = null;
   this._remoteType = null;
 
+  this._peerIdentity = {};
+
   /**
    * Everytime we get a request from content, we put it in the queue. If
    * there are no pending operations though, we will execute it immediately.
    * In PeerConnectionObserver, whenever we are notified that an operation
    * has finished, we will check the queue for the next operation and execute
    * if neccesary. The _pending flag indicates whether an operation is currently
    * in progress.
    */
@@ -286,20 +292,24 @@ RTCPeerConnection.prototype = {
     this.makeGetterSetterEH("onicecandidate");
     this.makeGetterSetterEH("onnegotiationneeded");
     this.makeGetterSetterEH("onsignalingstatechange");
     this.makeGetterSetterEH("onremovestream");
     this.makeGetterSetterEH("ondatachannel");
     this.makeGetterSetterEH("onconnection");
     this.makeGetterSetterEH("onclosedconnection");
     this.makeGetterSetterEH("oniceconnectionstatechange");
+    this.makeGetterSetterEH("onidentityresult");
 
     this._pc = Cc["@mozilla.org/peerconnection;1"].
              createInstance(Ci.IPeerConnection);
     this._observer = new PeerConnectionObserver(this);
+    this._idp = new PeerConnectionIDP(this);
+    this._idp.init('login.persona.org', 'default', null); //default inititalization values
+
     this._winID = this._win.QueryInterface(Ci.nsIInterfaceRequestor)
                            .getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
 
     // Add a reference to the PeerConnection to global list (before init).
     _globalPCList.addPC(this);
 
     // Nothing starts until ICE gathering completes.
     this._queueOrRun({
@@ -311,35 +321,41 @@ RTCPeerConnection.prototype = {
 
   _getPC: function() {
     if (!this._pc) {
       throw new Components.Exception("RTCPeerConnection is gone (did you enter Offline mode?)");
     }
     return this._pc;
   },
 
-  /**
-   * Add a function to the queue or run it immediately if the queue is empty.
-   * Argument is an object with the func, args and wait properties; wait should
-   * be set to true if the function has a success/error callback that will
-   * call _executeNext, false if it doesn't have a callback.
+    /**
+     * Add a function to the queue or run it immediately if the queue is empty.
+     * Argument is an object with the func, args and wait properties; wait should
+     * be set to true if the function has a success/error callback that will
+    * call _executeNext, false if it doesn't have a callback.
    */
   _queueOrRun: function(obj) {
+    // this.reportWarning("in _queueOrRun", null, 0);
     this._checkClosed();
     if (!this._pending) {
+      // this.reportWarning("none pending in _queueOrRun for ", null, 0);
       if (obj.type !== undefined) {
         this._pendingType = obj.type;
       }
+      // this.reportWarning("running in _queueOrRun for ", null, 0);
       obj.func.apply(this, obj.args);
+      // this.reportWarning("done running in _queueOrRun ", null, 0);
       if (obj.wait) {
         this._pending = true;
       }
     } else {
+      // this.reportWarning("push onto queue ", null, 0);
       this._queue.push(obj);
     }
+    // this.reportWarning("done _queueOrRun for ", null, 0);
   },
 
   // Pick the next item from the queue and run it.
   _executeNext: function() {
     if (this._queue.length) {
       let obj = this._queue.shift();
       if (obj.type !== undefined) {
         this._pendingType = obj.type;
@@ -466,16 +482,17 @@ RTCPeerConnection.prototype = {
   },
 
   // Ideally, this should be of the form _checkState(state),
   // where the state is taken from an enumeration containing
   // the valid peer connection states defined in the WebRTC
   // spec. See Bug 831756.
   _checkClosed: function() {
     if (this._closed) {
+      this.reportWarning("PEER CONNECTION CLOSED", null, 0);
       throw new Components.Exception("Peer connection is closed");
     }
   },
 
   dispatchEvent: function(event) {
     this.__DOM_IMPL__.dispatchEvent(event);
   },
 
@@ -637,16 +654,46 @@ RTCPeerConnection.prototype = {
     this._queueOrRun({
       func: this._getPC().setLocalDescription,
       args: [type, desc.sdp],
       wait: true,
       type: desc.type
     });
   },
 
+  setIdentityProvider: function(provider, protocol, username) {
+    if(this.signalingState == "closed") {
+      this.reportError('setIdentityProvider failed. signalingState is closed.', null, 0);
+    }
+    else {
+      this.reportWarning('setIdentityProvider is not yet fully implemented.', null, 0);
+      this._idp.init(provider, protocol, username); //initialize the idp
+    }
+  },
+
+  getIdentityAssertion: function() {
+    if(this.signalingState == "closed") {
+      this.reportError('getIdentityAssertion failed. signalingState is closed.', null, 0);
+    }
+    else {
+      this.reportWarning('getIdentityAssertion is not yet implemented.', null, 0);
+      if(!this._idp.set) {
+        /// get key fingerprint
+        this.reportWarning('setIdentityProvider has not been called.', null, 0);
+        this._idp.init('login.persona.org', 'default', null); //default inititalization values
+        var assertion = this._idp.requestIdentityAssertion(null);
+        this.reportWarning("GOT ASSERTION: " + JSON.stringify(assertion), null, 0);
+      }
+      else {
+        var assertion = this._idp.requestIdentityAssertion(null);
+        this.reportWarning("GOT ASSERTION: " + JSON.stringify(assertion), null, 0);
+      }
+    }
+  },
+
   setRemoteDescription: function(desc, onSuccess, onError) {
     // TODO -- if we have two setRemoteDescriptions in the
     // queue, this code overwrites the callbacks for the first
     // one with the callbacks for the second one. See Bug 831759.
     this._onSetRemoteDescriptionSuccess = onSuccess;
     this._onSetRemoteDescriptionFailure = onError;
 
     let type;
@@ -660,16 +707,48 @@ RTCPeerConnection.prototype = {
       case "pranswer":
         throw new Components.Exception("pranswer not yet implemented",
                                        Cr.NS_ERROR_NOT_IMPLEMENTED);
       default:
         throw new Components.Exception("Invalid type " + desc.type +
                                        " provided to setRemoteDescription");
     }
 
+    let verifyCallback = function(email) {
+      let message, icon, priority;
+      let browser = this._win.QueryInterface(Ci.nsIInterfaceRequestor)
+                       .getInterface(Ci.nsIWebNavigation)
+                       .QueryInterface(Ci.nsIDocShell).chromeEventHandler;
+      let gBrowser = browser.ownerDocument.defaultView.gBrowser;
+      let notificationBox = gBrowser.getNotificationBox();
+
+      if(!email) {
+        message = "WARNING: We could not verify the identity of the other party.";
+        icon = "chrome://global/skin/icons/warning-16.png";
+        priority = notificationBox.PRIORITY_WARNING_HIGH;
+      }
+      else  {
+        message = "You are now talking securely to " + email;
+        icon = "chrome://browser/skin/Secure-Glyph.png";
+        priority = notificationBox.PRIORITY_WARNING_MEDIUM;
+      }
+
+      let buttons = [
+      // {
+      //   label: "Okay",
+      //   accessKey: "Y",
+      //   popup: "test",
+      //   callback: null
+      // }
+      ];
+
+      notificationBox.appendNotification(message, "webrtc-auth", icon, priority, buttons);
+    }.bind(this);
+    this._idp.verifySDP(desc.sdp, verifyCallback);
+
     this._queueOrRun({
       func: this._getPC().setRemoteDescription,
       args: [type, desc.sdp],
       wait: true,
       type: desc.type
     });
   },
 
@@ -740,16 +819,20 @@ RTCPeerConnection.prototype = {
     this.deprecated("localStreams");
     return this.getLocalStreams();
   },
   get remoteStreams() {
     this.deprecated("remoteStreams");
     return this.getRemoteStreams();
   },
 
+  get peerIdentity() {
+    return this._peerIdentity;
+  },
+
   get localDescription() {
     this._checkClosed();
     let sdp = this._getPC().localDescription;
     if (sdp.length == 0) {
       return null;
     }
     return new this._win.mozRTCSessionDescription({ type: this._localType,
                                                     sdp: sdp });
@@ -932,31 +1015,39 @@ PeerConnectionObserver.prototype = {
         // want this to take down peerconnection, but we still want the user
         // to see it, so we catch it, report it, and move on.
         this._dompc.reportError(e.message, e.fileName, e.lineNumber);
       }
     }
   },
 
   onCreateOfferSuccess: function(sdp) {
-    this.callCB(this._dompc._onCreateOfferSuccess,
+    // getIdentityAssertion here and pass in the sdp
+    let onAssertionCB = function(sdp) {
+      this.callCB(this._dompc._onCreateOfferSuccess,
                 new this._dompc._win.mozRTCSessionDescription({ type: "offer",
                                                                 sdp: sdp }));
+    }.bind(this);
+    this._dompc._idp.requestIdentityAssertion(sdp, onAssertionCB);
     this._dompc._executeNext();
   },
 
   onCreateOfferError: function(code, message) {
     this.callCB(this._dompc._onCreateOfferFailure, new RTCError(code, message));
     this._dompc._executeNext();
   },
 
   onCreateAnswerSuccess: function(sdp) {
-    this.callCB (this._dompc._onCreateAnswerSuccess,
+    //attach the sdp assertion to asnswer as well
+    let onAssertionCB = function(sdp) {
+      this.callCB (this._dompc._onCreateAnswerSuccess,
                  new this._dompc._win.mozRTCSessionDescription({ type: "answer",
                                                                  sdp: sdp }));
+    }.bind(this);
+    this._dompc._idp.requestIdentityAssertion(sdp, onAssertionCB);
     this._dompc._executeNext();
   },
 
   onCreateAnswerError: function(code, message) {
     this.callCB(this._dompc._onCreateAnswerFailure, new RTCError(code, message));
     this._dompc._executeNext();
   },
 
@@ -1056,16 +1147,20 @@ PeerConnectionObserver.prototype = {
       case Ci.IPeerConnectionObserver.kSdpState:
         // No-op
         break;
 
       case Ci.IPeerConnectionObserver.kSipccState:
         // No-op
         break;
 
+      case 1:
+        //TODO REMOVE AFTER TESTING
+        break;
+
       default:
         this._dompc.reportWarning("Unhandled state type: " + state, null, 0);
         break;
     }
   },
 
   onAddStream: function(stream) {
     this.dispatchEvent(new this._dompc._win.MediaStreamEvent("addstream",
@@ -1088,15 +1183,179 @@ PeerConnectionObserver.prototype = {
   },
 
   notifyConnection: function() {
     this.dispatchEvent(new this._dompc._win.Event("connection"));
   },
 
   notifyClosedConnection: function() {
     this.dispatchEvent(new this._dompc._win.Event("closedconnection"));
+  },
+
+  notifyIdentityResult: function() {
+    this.dispatchEvent(new this._dompc._win.Event('identityresult'));
+  }
+};
+
+function PeerConnectionIDP(pc) {
+  this._dompc = pc; // peer connection object
+  this.fallback_provider = 'login.persona.org'; // browser specific fallback idp (we will use Persona)
+  this.provider = null; // user specified idp domain (gmail.com/login.persona.org/yahoo.com)
+  this.protocol = null; // protocol to use ("default")
+  this.username = null; // "assertion" used to verify the identity
+  this.set = false; // true if the IDP has been initialized previously
+  this.idpChannel = null;
+  this.messages = {};
+  this.messageCount = 0;
+};
+PeerConnectionIDP.prototype = {
+  init: function(provider, protocol, username) {
+    // set the required values
+    this.set = true;
+    this.setIDP(provider, protocol, username);
+    this.idpChannel = new IDPChannel(this.onMessage.bind(this));
+    this._dompc.reportWarning('IDP has been (re-)initialized.', null, 0);
+  },
+
+  onMessage: function(message) {
+    // got assertion message, add it to sdp and call callback
+    // format of message currently: {"method":"SUCCESS","origin":"https://example.com","message":"TESTSIGN"}
+
+
+    // RETURNED FROM SIGN MESSAGE
+    // {
+    //   "type":"SUCCESS",
+    //   "id":1,
+    //   "message": {
+    //     "idp":{
+    //       "domain": "example.org"
+    //       "protocol": "bogus"
+    //     },
+    //     "assertion":\"{\"identity\":\"bob@example.org\",
+    //                    \"contents\":\"abcdefghijklmnopqrstuvwyz\",
+    //                    \"request_origin\":\"rtcweb://peerconnection\",
+    //                    \"signature\":\"010203040506\"}"
+    //   }
+    // }
+
+    // RETURNED FROM VERIFY MESSAGE
+    // {
+    //   "type":"SUCCESS",
+    //   "id":2,
+    //   "message": {
+    //     "identity" : {
+    //       "name" : "bob@example.org",
+    //       "displayname" : "Bob"
+    //     },
+    //     "request_origin":"rtcweb://peerconnection",
+    //     "contents":"abcdefghijklmnopqrstuvwyz" //fingerprint
+    //   }
+    // }
+
+    dump("GOT MESSAGE: " + JSON.stringify(message));
+
+    // let message = JSON.parse(message);
+    if(!message) return;
+    let msg = message.message || {};
+    let identity = msg.identity || {};
+    let stored = this.messages[message.id] || { callback: function(){} }; // lookup stored message
+    if(message.type == 'SUCCESS') {
+      if(stored.type == 'SIGN') {
+        stored.sdp += "a=identity: " + msg.assertion;
+        return stored.callback(stored.sdp); // callback with sdp + assertion
+      }
+      else if(stored.type == 'VERIFY') {
+        if(msg.request_origin == "rtcweb://peerconnection") {
+          return stored.callback(identity.name); // no error: callback with email
+        }
+      }
+    }
+    else if(message.type == "ERROR"){
+      dump("ERROR: " + message.error);
+    }
+    return stored.callback(null);
+  },
+
+  requestIdentityAssertion: function(sdp, callback) {
+    if(!callback) return; // no callback
+    if(!sdp) return callback(null); // throw an error?
+
+    this.sdp = sdp;
+
+    // get the key fingerprint from the sdp and use it when getting an assertion
+    let pattern = /\na=fingerprint:\s*(\S+\s*\S*)/i;
+    let fingerprint = sdp.match(pattern)[1];
+
+    let browser = this._dompc._win.QueryInterface(Ci.nsIInterfaceRequestor)
+                       .getInterface(Ci.nsIWebNavigation)
+                       .QueryInterface(Ci.nsIDocShell).chromeEventHandler;
+    let gBrowser = browser.ownerDocument.defaultView.gBrowser;
+
+    let data = {
+      type: 'SIGN',
+      id: this.messageCount,
+      origin: gBrowser.currentURI.spec, // "http://example.com/example" <-- entire url
+      message: fingerprint
+    };
+
+    this.messages[this.messageCount++] = {
+      sdp: sdp,
+      type: 'SIGN',
+      message: fingerprint,
+      callback: callback
+    };
+
+    //send fingerprint to idp channel to create assertion
+    this.idpChannel.send(data);
+  },
+
+  setIDP: function(provider, protocol, username) {
+    this.provider = provider;
+    this.protocol = protocol;
+    this.username = username;
+  },
+
+  getProvider: function() {
+    return this.provider || this.fallback_provider;
+  },
+
+  verifySDP: function(sdp, callback) {
+    if(!sdp) return callback(null);
+
+    let assertion = null;
+    let fingerprint = null;
+
+    let fp_patt = /\na=fingerprint:\s*(\S+\s*\S*)/i; // TODO: test the shit outta this
+    let fingerprint_matches = sdp.match(fp_patt);
+    if(!fingerprint_matches) return callback(null); // no matches? (shouldn't happen)
+    else fingerprint = fingerprint_matches[1];
+
+    let id_patt = /\na=identity:\s*(\S+\s*\S*)/i; // TODO: test the shit outta this too
+    let assertion_matches = sdp.match(id_patt);
+    let assertion = null;
+    if(!assertion_matches) return callback(null); //no matches (old browser?)
+    else assertion = assertion_matches[1]; // a match!
+
+    let message = {
+      'identity': assertion,
+      'fingerprint': fingerprint
+    };
+
+    let data = {
+      type: 'VERIFY',
+      id: this.messageCount,
+      message: assertion
+    };
+
+    this.messages[this.messageCount++] = {
+      type: 'VERIFY',
+      message: message,
+      callback: callback
+    };
+
+    this.idpChannel.send(data);
   }
 };
 
 this.NSGetFactory = XPCOMUtils.generateNSGetFactory(
   [GlobalPCList, RTCIceCandidate, RTCSessionDescription, RTCPeerConnection,
    RTCPeerConnectionIceEvent, MediaStreamEvent, RTCDataChannelEvent]
 );
diff --git a/dom/media/PeerConnection.manifest b/dom/media/PeerConnection.manifest
--- a/dom/media/PeerConnection.manifest
+++ b/dom/media/PeerConnection.manifest
@@ -1,15 +1,17 @@
 component {9878b414-afaa-4176-a887-1e02b3b047c2} PeerConnection.js
 component {02b9970c-433d-4cc2-923d-f7028ac66073} PeerConnection.js
 component {1775081b-b62d-4954-8ffe-a067bbf508a7} PeerConnection.js
 component {7293e901-2be3-4c02-b4bd-cbef6fc24f78} PeerConnection.js
 component {b9cd25a7-9859-4f9e-8f84-ef5181ff36c0} PeerConnection.js
 component {a722a8a9-2290-4e99-a5ed-07b504292d08} PeerConnection.js
 component {d5ed7fbf-01a8-4b18-af6c-861cf2aac920} PeerConnection.js
+component {498df9b5-87dd-40e5-b717-9cab40b1f99b} PeerConnection.js
 
 contract @mozilla.org/dom/peerconnection;1 {9878b414-afaa-4176-a887-1e02b3b047c2}
 contract @mozilla.org/dom/rtcicecandidate;1 {02b9970c-433d-4cc2-923d-f7028ac66073}
 contract @mozilla.org/dom/rtcsessiondescription;1 {1775081b-b62d-4954-8ffe-a067bbf508a7}
+contract @mozilla.org/dom/rtcidentityassertion;1 {498df9b5-87dd-40e5-b717-9cab40b1f99b}
 contract @mozilla.org/dom/peerconnectionmanager;1 {7293e901-2be3-4c02-b4bd-cbef6fc24f78}
 contract @mozilla.org/dom/rtcpeerconnectioniceevent;1 {b9cd25a7-9859-4f9e-8f84-ef5181ff36c0}
 contract @mozilla.org/dom/mediastreamevent;1 {a722a8a9-2290-4e99-a5ed-07b504292d08}
 contract @mozilla.org/dom/datachannelevent;1 {d5ed7fbf-01a8-4b18-af6c-861cf2aac920}
diff --git a/dom/webidl/RTCIdentityAssertion.webidl b/dom/webidl/RTCIdentityAssertion.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/RTCIdentityAssertion.webidl
@@ -0,0 +1,12 @@
+dictionary RTCIdentityAssertionInit {
+  DOMString? idp = null;
+  DOMString? name = null;
+};
+
+[Pref="media.peerconnection.enabled",
+ JSImplementation="@mozilla.org/dom/rtcidentityassertion;1",
+ Constructor(optional RTCIdentityAssertionInit assertionInitDict)]
+interface RTCIdentityAssertion {
+  attribute DOMString? idp;
+  attribute DOMString? name;
+};
diff --git a/dom/webidl/RTCPeerConnection.webidl b/dom/webidl/RTCPeerConnection.webidl
--- a/dom/webidl/RTCPeerConnection.webidl
+++ b/dom/webidl/RTCPeerConnection.webidl
@@ -4,16 +4,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/.
  *
  * The origin of this IDL file is
  * http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCPeerConnection
  */
 
 callback RTCSessionDescriptionCallback = void (mozRTCSessionDescription sdp);
 callback RTCPeerConnectionErrorCallback = void (DOMString errorInformation);
+callback RTCIdentityResultCallback = void (RTCIdentityAssertion result);
 callback VoidFunction = void ();
 
 enum RTCSignalingState {
     "stable",
     "have-local-offer",
     "have-remote-offer",
     "have-local-pranswer",
     "have-remote-pranswer",
@@ -63,41 +64,49 @@ interface mozRTCPeerConnection : EventTa
                     RTCPeerConnectionErrorCallback? failureCallback, // for apprtc
                     optional object? constraints);
   void createAnswer (RTCSessionDescriptionCallback successCallback,
                      RTCPeerConnectionErrorCallback? failureCallback, // for apprtc
                      optional object? constraints);
   void setLocalDescription (mozRTCSessionDescription description,
                             optional VoidFunction successCallback,
                             optional RTCPeerConnectionErrorCallback failureCallback);
+  void setIdentityProvider (DOMString provider,
+                            optional DOMString protocol,
+                            optional DOMString username);
+  void getIdentityAssertion ();
   void setRemoteDescription (mozRTCSessionDescription description,
                              optional VoidFunction successCallback,
                              optional RTCPeerConnectionErrorCallback failureCallback);
   readonly attribute mozRTCSessionDescription? localDescription;
   readonly attribute mozRTCSessionDescription? remoteDescription;
   readonly attribute RTCSignalingState signalingState;
+
   void updateIce (optional RTCConfiguration configuration,
                   optional object? constraints);
   void addIceCandidate (mozRTCIceCandidate candidate,
                         optional VoidFunction successCallback,
                         optional RTCPeerConnectionErrorCallback failureCallback);
   readonly attribute RTCIceGatheringState iceGatheringState;
   readonly attribute RTCIceConnectionState iceConnectionState;
+
   sequence<MediaStream> getLocalStreams ();
   sequence<MediaStream> getRemoteStreams ();
   MediaStream? getStreamById (DOMString streamId);
   void addStream (MediaStream stream, optional object? constraints);
   void removeStream (MediaStream stream);
   void close ();
   attribute EventHandler onnegotiationneeded;
   attribute EventHandler onicecandidate;
   attribute EventHandler onsignalingstatechange;
   attribute EventHandler onaddstream;
   attribute EventHandler onremovestream;
   attribute EventHandler oniceconnectionstatechange;
+
+  readonly attribute RTCIdentityAssertion peerIdentity;
 };
 
 // Mozilla extensions.
 partial interface mozRTCPeerConnection {
   // Deprecated callbacks (use causes warning)
   attribute RTCPeerConnectionErrorCallback onicechange;
   attribute RTCPeerConnectionErrorCallback ongatheringchange;
 
@@ -107,9 +116,11 @@ partial interface mozRTCPeerConnection {
   readonly attribute DOMString readyState;
 
   // Data channel.
   RTCDataChannel createDataChannel (DOMString label,
                                     optional RTCDataChannelInit dataChannelDict);
   attribute EventHandler ondatachannel;
   attribute EventHandler onconnection;
   attribute EventHandler onclosedconnection;
+
+  attribute EventHandler onidentityresult;
 };
diff --git a/dom/webidl/WebIDL.mk b/dom/webidl/WebIDL.mk
--- a/dom/webidl/WebIDL.mk
+++ b/dom/webidl/WebIDL.mk
@@ -211,16 +211,17 @@ webidl_files = \
   Rect.webidl \
   RGBColor.webidl \
   RTCConfiguration.webidl \
   RTCDataChannelEvent.webidl \
   RTCIceCandidate.webidl \
   RTCPeerConnection.webidl \
   RTCPeerConnectionIceEvent.webidl \
   RTCSessionDescription.webidl \
+  RTCIdentityAssertion.webidl \
   Screen.webidl \
   ScriptProcessorNode.webidl \
   ScrollAreaEvent.webidl \
   SimpleGestureEvent.webidl \
   StyleSheet.webidl \
   SVGAElement.webidl \
   SVGAltGlyphElement.webidl \
   SVGAngle.webidl \
