# HG changeset patch
# Parent 34413584ca6b9984aa9ab9a3046566137b259b96
# User Jed Parsons <jparsons@mozilla.com>
# Date Wed Jun 12 16:35:42 2013 -0700
Bug 878941 - IdP Proxy and communication channel for RTC peer connection (wip)

diff --git a/browser/base/content/rtc-persona-framescript.js b/browser/base/content/rtc-persona-framescript.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/rtc-persona-framescript.js
@@ -0,0 +1,119 @@
+/* -*- Mode: js2; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
+/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// This JS shim contains the callbacks to fire DOMRequest events for
+// navigator.mozId API within the caller's scope.
+
+'use strict';
+
+let { classes: Cc, interfaces: Ci, utils: Cu } = Components;
+Cu.import('resource://gre/modules/XPCOMUtils.jsm');
+
+function log(msg) {
+  dump(" ** rtc shim: " + msg + "\n");
+}
+
+function IdentityShim() {
+  this.isLoaded = false;
+}
+
+IdentityShim.prototype = {
+  init: function IdentityShim_init() {
+    addMessageListener('rtcid-message', this);
+    log("init; sending rtcid-loaded");
+    sendAsyncMessage('rtcid-loaded');
+    this.isLoaded = true;
+  },
+
+  uninit: function IdentityShim_uninit() {
+    if (this.isLoaded) {
+      removeMessageListener('rtcid-message', this);
+      log("uninit; sending rtcid-complete");
+      sendAsyncMessage('rtcid-complete', null);
+      this.isLoaded = false;
+    }
+  },
+
+  receiveMessage: function IdentityShim_receiveMessage(aMessage) {
+    let data = aMessage.json;
+    log("receiveMessage: " + JSON.stringify(data));
+    switch (data.message.type) {
+      case 'SIGN':
+        this.sign(data);
+        break;
+      default:
+        log("ERROR: unknown messge type: " + data.type);
+        break;
+    }
+  },
+
+  sendResponse: function IdentityShim_sendResponse(message) {
+    log("send response:" + message);
+    sendAsyncMessage('rtcid-response', message);
+  },
+
+  _close: function IdentityShim__close() {
+    this.uninit();
+  },
+
+  sign: function IdentityShim_sign(data) {
+    log("sign received: " + JSON.stringify(data));
+    let message = data.message;
+    let stringifiedOptions = JSON.stringify({
+      silent: true,
+      origin: message.origin,
+      payload: { extra : { webrtc: { fingerprint : message.message }}}
+    });
+    log("sign extra data: " + stringifiedOptions);
+    let callback = function shim_getCallback(assertion) {
+      log("yay! internal.get called back with assertion: " + assertion);
+      this.sendResponse({
+        type: (assertion ? 'SUCCESS' : 'FAILURE'),
+        id: message.id,
+        message: {
+          idp: {
+            domain: message.origin,
+            protocol: "browserid"
+          },
+          assertion: assertion
+        }
+      });
+      this._close();
+    }.bind(this);
+
+    log("calling get");
+    content.wrappedJSObject.BrowserID.internal.get(
+      'rtcweb://peerconnection',
+      callback,
+      stringifiedOptions
+    );
+    log("called get with options: " + typeof stringifiedOptions + ': ' + stringifiedOptions);
+  }
+};
+
+this.shim = null;
+
+// XXX wha?  why both events
+// dump out these events - should just be on 'load'
+addEventListener('DOMContentLoaded', function(e) {
+  log("got DOMContentLoaded");
+  content.addEventListener('load', function(e) {
+    log("got load event");
+    this.shim = new IdentityShim();
+    this.shim.init();
+  });
+});
+
+// Having an event listener for 'unload' prevents the page from
+// being cached.  So use 'pagehide' instead.
+// https://developer.mozilla.org/en-US/docs/Using_Firefox_1.5_caching
+content.addEventListener('pagehide', function(e) {
+  log("got pagehide event");
+  if (this.shim) {
+    this.shim.uninit();
+  }
+});
+
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -67,16 +67,17 @@ browser.jar:
 *       content/browser/pageinfo/pageInfo.xul         (content/pageinfo/pageInfo.xul)
         content/browser/pageinfo/pageInfo.js          (content/pageinfo/pageInfo.js)
         content/browser/pageinfo/pageInfo.css         (content/pageinfo/pageInfo.css)
         content/browser/pageinfo/pageInfo.xml         (content/pageinfo/pageInfo.xml)
         content/browser/pageinfo/feeds.js             (content/pageinfo/feeds.js)
         content/browser/pageinfo/feeds.xml            (content/pageinfo/feeds.xml)
         content/browser/pageinfo/permissions.js       (content/pageinfo/permissions.js)
         content/browser/pageinfo/security.js          (content/pageinfo/security.js)
+        content/browser/rtc-persona-framescript.js    (content/rtc-persona-framescript.js)
 #ifdef MOZ_SERVICES_SYNC
         content/browser/sync/aboutSyncTabs.xul        (content/sync/aboutSyncTabs.xul)
         content/browser/sync/aboutSyncTabs.js         (content/sync/aboutSyncTabs.js)
         content/browser/sync/aboutSyncTabs.css        (content/sync/aboutSyncTabs.css)
         content/browser/sync/aboutSyncTabs-bindings.xml  (content/sync/aboutSyncTabs-bindings.xml)
 *       content/browser/sync/setup.xul                (content/sync/setup.xul)
         content/browser/sync/addDevice.js             (content/sync/addDevice.js)
         content/browser/sync/addDevice.xul            (content/sync/addDevice.xul)
diff --git a/toolkit/identity/RTCIdentity.jsm b/toolkit/identity/RTCIdentity.jsm
new file mode 100644
--- /dev/null
+++ b/toolkit/identity/RTCIdentity.jsm
@@ -0,0 +1,369 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+ * An Authentication Module for RTC that uses Persona
+ *
+ *
+ */
+
+"use strict";
+
+this.EXPORTED_SYMBOLS = ["IDPChannel", "HostFrame", "Pipe", "unpackAssertion"];
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+const crypto = Cc["@mozilla.org/identity/crypto-service;1"]
+                 .getService(Ci.nsIIdentityCryptoService);
+
+
+// XXX while developing this, we use an ephemeral instance of persona that
+// provides new functionality we need, namely fingerprint-wrapping in the
+// assertion.
+//let kPersonaUri = "https://webrtc.personatest.org";
+let kPersonaUri = "http://127.0.0.1:10002";
+try {
+  kPersonaUri = Services.prefs.getCharPref("toolkit.identity.uri");
+} catch (noSuchPref) {
+  // stick with the default value
+}
+
+let kVerifierUri = "https://verifier.login.persona.org/verify";
+try {
+  kVerifierUri = Services.prefs.getCharPref("toolkit.identity.verifier_uri");
+} catch (noSuchPref) {
+  // stick with the default value
+}
+
+function log(msg) {
+  dump("* RTCIdentity: " + msg + "\n");
+}
+
+log("**** using persona uri: " + kPersonaUri);
+
+function unpackAssertion(signedObject) {
+  if (typeof(signedObject) !== "string") {
+    throw new Error("Malformed assertion");
+  }
+
+  var parts = signedObject.split(".");
+  return {header: JSON.parse(crypto.base64UrlDecode(parts[0])),
+          payload: JSON.parse(crypto.base64UrlDecode(parts[1])),
+          signature: parts[2],
+          assertion: JSON.parse(crypto.base64UrlDecode(parts[3]))};
+};
+
+
+/*
+ * An invisible iframe for hosting the persona logic.
+ *
+ * There is no visible UX here, as we assume the user has already
+ * logged in elsewhere (on a different screen in the web site hosting
+ * the RTC functions).  So all we have to do is get an assertion from
+ * Persona.
+ */
+this.HostFrame = function HostFrame() {
+  this._iframe = null;
+};
+
+HostFrame.prototype = {
+  getIframe: function hostFrame_getIframe(aOptions, aCallback) {
+    if (this._gotIframe) {
+      return aCallback(
+        new Error("Can only get iframe once with HostFrame helper"));
+    }
+
+    let hiddenDoc = Services.appShell.hiddenDOMWindow.document;
+
+    this._iframe = hiddenDoc.createElementNS(
+        "http://www.w3.org/1999/xhtml", "iframe");
+
+    this._iframe.setAttribute("mozframetype", "content");
+    this._iframe.setAttribute("id", "persona-host-frame");
+    this._iframe.setAttribute("src",
+        (aOptions.idpUri || kPersonaUri) + '/communication_iframe');
+
+    aOptions.iframe = this._iframe;
+
+    hiddenDoc.documentElement.appendChild(this._iframe);
+
+    // Inject a framescript into the iframe that can receive messages
+    // from its parent process telling it which persona internal_api
+    // methods to call.
+    this._iframe
+      .QueryInterface(Ci.nsIFrameLoaderOwner)
+      .frameLoader.messageManager
+      .loadFrameScript("chrome://browser/content/rtc-persona-framescript.js", true);
+
+    // no error
+    aCallback(null);
+  }
+};
+
+this.Pipe = function Pipe(aOptions, aController) {
+  this.options = aOptions;
+  this.controller = aController;
+  this.mm = null;
+  this._closed = false;
+  return this;
+};
+
+Pipe.prototype = {
+  close: function pipe__close() {
+    this._closed = true;
+    if (this.mm) {
+      this.mm.removeMessageListener("rtcid-response", this._receiveMessage);
+      this.mm.removeMessageListener("rtcid-complete", this._delegateComplete);
+      this.mm.removeMessageListener("rtcid-loaded", this._delegateLoaded);
+    }
+  },
+
+  _delegateLoaded: function pipe__delegateLoaded() {
+    this.mm.sendAsyncMessage('rtcid-message', this.options);
+  },
+
+  _delegateComplete: function pipe__delegateComplete() {
+    this.close();
+  },
+
+  _receiveMessage: function pipe__receiveMessage(message) {
+    this.controller.receiveResponse(message.json);
+  },
+
+  communicate: function pipe_communicate() {
+    if (this._closed) {
+      logger.error("Cannot communicate; pipe is closed");
+      return;
+    }
+
+    let frameLoader = this.options.iframe.QueryInterface(
+        Ci.nsIFrameLoaderOwner).frameLoader;
+
+    if (frameLoader) {
+      this.mm = frameLoader.messageManager;
+      this.mm.addMessageListener("rtcid-response", this._receiveMessage.bind(this));
+      this.mm.addMessageListener("rtcid-loaded", this._delegateLoaded.bind(this));
+      this.mm.addMessageListener("rtcid-complete", this._delegateComplete.bind(this));
+    } else {
+      logger.error("Frame loader unavailable; frame attached properly?");
+    }
+  }
+};
+
+/*
+ * aOptions can be used in testing to mock various components
+ */
+function IDPChannel(messageCallback, aOptions) {
+  aOptions = aOptions || {};
+  this.receiveResponse = messageCallback;
+  this.pipeConstructor = aOptions.PipeConstructor || Pipe;
+  this.hostFrameConstructor = aOptions.HostFrameConstructor || HostFrame;
+  this.verifierUri = aOptions.verifierUri || kVerifierUri;
+  this.idpUri = aOptions.idpUri || kPersonaUri;
+  this.pipe = null;
+
+  // https://tools.ietf.org/html/draft-ietf-rtcweb-security-arch-06#section-5.6.5.2
+  this.receiveResponse({type: "READY"});
+}
+
+IDPChannel.prototype = {
+  /*
+   * use the persona communication_iframe to request an assertion
+   *
+   * https://tools.ietf.org/html/draft-ietf-rtcweb-security-arch-06#section-5.6.5.2.2
+   * Example transaction:
+   *
+   *
+   *  PeerConnection -> IdP proxy:
+   *    {
+   *      "type":"SIGN",
+   *       "id":1,
+   *       "origin":"https://calling-service.example.com/",
+   *       "message":"abcdefghijklmnopqrstuvwyz"
+   *    }
+   *
+   *  IdPProxy -> PeerConnection:
+   *    {
+   *      "type":"SUCCESS",
+   *      "id":1,
+   *      "message": {
+   *        "idp":{
+   *          "domain": "example.org"
+   *          "protocol": "bogus"
+   *        },
+   *        "assertion":\"{\"identity\":\"bob@example.org\",
+   *                       \"contents\":\"abcdefghijklmnopqrstuvwyz\",
+   *                       \"request_origin\":\"rtcweb://peerconnection\",
+   *                       \"signature\":\"010203040506\"}"
+   *      }
+   *    }
+   *
+   */
+  _sign: function idpChannel__sign(message) {
+    let hostFrame = new this.hostFrameConstructor();
+    let options = {
+      idpUri: this.idpUri,
+      message: message
+    };
+    log("sign: " + JSON.stringify(options, null, 2));
+    hostFrame.getIframe(options, function() {
+      // iframe has been added to options
+
+      // callback for the pipe when flow is complete
+      options.onComplete = function pipe_onComplete(response) {
+        this.pipe.close();
+      }.bind(this);
+
+      this.pipe = new this.pipeConstructor(options, this);
+      this.pipe.communicate();
+    }.bind(this));
+  },
+
+  /*
+   * communicate with the persona verifier to verify the assertion.
+   * XXX this should be done completely natively with no httprequest
+   * XXX for now, this is quick and easy
+   *
+   * https://tools.ietf.org/html/draft-ietf-rtcweb-security-arch-06#section-5.6.5.2.3
+   * An example transaction:
+   *
+   *    PeerConnection -> IdP Proxy:
+   *      {
+   *        "type":"VERIFY",
+   *        "id":2,
+   *        "origin":"https://calling-service.example.com/",
+   *        "message":\"{\"identity\":\"bob@example.org\",
+   *                     \"contents\":\"abcdefghijklmnopqrstuvwyz\",
+   *                     \"request_origin\":\"rtcweb://peerconnection\",
+   *                     \"signature\":\"010203040506\"}"
+   *      }
+   *
+   *    IdP Proxy -> PeerConnection:
+   *      {
+   *       "type":"SUCCESS",
+   *       "id":2,
+   *       "message": {
+   *         "identity" : {
+   *           "name" : "bob@example.org",
+   *           "displayname" : "Bob"
+   *         },
+   *         "request_origin":"rtcweb://peerconnection",
+   *         "contents":"abcdefghijklmnopqrstuvwyz"
+   *       }
+   *      }
+   *
+   *
+   */
+  _verify: function idpChannel__verify(message) {
+    // message.message should be the base64-encoded assertion as a string
+    let assertion = message.message;
+    let assertion_payload = null;
+    let assertion_aud = null;
+    try {
+      let obj = JSON.parse(crypto.base64UrlDecode(assertion.split("~")[1].split('.')[1]));
+      // obj = { "fingerprint" : "DE:AD:BE:EF", "exp" : 1372890745118, "aud" : "rtcweb://peerconnection" }
+      assertion_payload = obj.extra.webrtc.fingerprint;
+      assertion_aud = obj.aud;
+    }
+    catch(err) {
+      log(err);
+      // keep original null values
+    }
+
+    var body, res;
+    try {
+      body = JSON.stringify({
+        assertion: assertion,
+        audience: assertion_aud
+      });
+      log("verify: " + body);
+    } catch (err) {
+      this.receiveResponse(new Error("Cannot verify message; bad json"));
+    }
+
+    let req = Cc['@mozilla.org/xmlextras/xmlhttprequest;1']
+                .createInstance(Ci.nsIXMLHttpRequest);
+
+    req.open('POST', this.verifierUri, true);
+    req.responseType = 'json';
+    req.setRequestHeader('Content-Type', 'application/json');
+    req.mozBackgroundRequest = true;
+
+    req.onload = function idpChannel__verify_onload() {
+      let response = req.response;
+      // The 'error' message is not in the spec.
+      // Leaving it in for now, so we can debug more easily
+      if (req.status === 200) {
+        if (response) {
+          if (response.status === "okay") {
+            this.receiveResponse({
+              type: "SUCCESS",
+              id: message.id,
+              message: {
+                identity: {
+                  name: response.email,
+                  displayname: ""     // not something persona knows
+                },
+                request_origin: assertion_aud,
+                contents: assertion_payload
+              }
+            });
+          } else { // not "okay"
+            this.receiveResponse({
+              type: "ERROR",
+              id: message.id,
+              error: response.reason
+            });
+          }
+        } else { // no response
+          this.receiveResponse({
+            type: "ERROR",
+            id: message.id,
+            error: "Server response was " + typeof response
+          });
+        }
+      } else { // status != 200
+        this.receiveResponse({
+          type: "ERROR",
+          id: message.id,
+          error: "Server responded with code " + req.status
+        });
+      }
+    }.bind(this);
+
+    req.onerror = function idpChannel__verify_onerror() {
+      log('request error:', req.status, req.statusText);
+      this.receiveResponse({
+        type: "ERROR",
+        id: message.id,
+        error: "Request error"
+      });
+    }.bind(this);
+
+    req.send(body);
+  },
+
+  send: function idpChannel_send(message) {
+    log("send received: " + JSON.stringify(message));
+    switch (message.type) {
+      case "SIGN":
+        this._sign(message);
+        break;
+      case "VERIFY":
+        this._verify(message);
+        break;
+      default:
+        this.receiveResponse(new Error("Unknown message type: " + message.type));
+        break;
+    }
+  }
+};
+
+this.unpackAssertion = unpackAssertion;
+this.HostFrame = HostFrame;
+this.Pipe = Pipe;
+this.IDPChannel = IDPChannel;
diff --git a/toolkit/identity/moz.build b/toolkit/identity/moz.build
--- a/toolkit/identity/moz.build
+++ b/toolkit/identity/moz.build
@@ -22,12 +22,13 @@ JS_MODULES_PATH = 'modules/identity'
 
 EXTRA_JS_MODULES += [
     'Identity.jsm',
     'IdentityProvider.jsm',
     'IdentityStore.jsm',
     'IdentityUtils.jsm',
     'LogUtils.jsm',
     'MinimalIdentity.jsm',
+    'RTCIdentity.jsm',
     'RelyingParty.jsm',
     'Sandbox.jsm',
     'jwcrypto.jsm',
 ]
diff --git a/toolkit/identity/tests/unit/test_load_modules.js b/toolkit/identity/tests/unit/test_load_modules.js
--- a/toolkit/identity/tests/unit/test_load_modules.js
+++ b/toolkit/identity/tests/unit/test_load_modules.js
@@ -3,16 +3,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const modules = [
   "Identity.jsm",
   "IdentityProvider.jsm",
   "IdentityStore.jsm",
   "jwcrypto.jsm",
   "RelyingParty.jsm",
+  "RTCIdentity.jsm",
   "Sandbox.jsm",
 ];
 
 function run_test() {
   for each (let m in modules) {
     let resource = "resource://gre/modules/identity/" + m;
     Components.utils.import(resource, {});
     do_print("loaded " + resource);
diff --git a/toolkit/identity/tests/unit/test_rtcauthmodule.js b/toolkit/identity/tests/unit/test_rtcauthmodule.js
new file mode 100644
--- /dev/null
+++ b/toolkit/identity/tests/unit/test_rtcauthmodule.js
@@ -0,0 +1,209 @@
+
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://testing-common/httpd.js");
+
+XPCOMUtils.defineLazyModuleGetter(this, "IDPChannel",
+  "resource://gre/modules/identity/RTCIdentity.jsm",
+  "IDPChannel");
+
+XPCOMUtils.defineLazyModuleGetter(this, "Pipe",
+  "resource://gre/modules/identity/RTCIdentity.jsm",
+  "Pipe");
+
+XPCOMUtils.defineLazyModuleGetter(this, "HostFrame",
+  "resource://gre/modules/identity/RTCIdentity.jsm",
+  "HostFrame");
+
+XPCOMUtils.defineLazyModuleGetter(this, "unpackAssertion",
+  "resource://gre/modules/identity/RTCIdentity.jsm",
+  "unpackAssertion");
+
+// Example fingerprint taken from draft specification:
+// http://tools.ietf.org/html/draft-ietf-rtcweb-security-arch-06#section-5.6.4.1
+const FINGERPRINT = {
+  algorithm: "SHA-1",
+  digest: "4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB"
+};
+const USER_IDENTITY = "alice@example.com";
+const MOCK_ASSERTION = "I like pie";
+const ASSERTION = "eyJhbGciOiJSUzI1NiJ9.eyJwdWJsaWMta2V5Ijp7ImFsZ29yaXRobSI6IkRTIiwieSI6ImExOWI2YzEwNmMxMDg1OTkzZDgyMzZlZGQxZmIxNzdiZDc0NzU4NWI0NTZhYWNmOTM1MmI4M2ZhODcwYWZlN2I3YjBhMDUyMWUwNmRiOWRiYzFjODYxYjAwZDhjYzJkMjhkZTYzYWQ2Y2MxYjgxMzVjMTZhMDgwOTgwMTMwZWI0MmQ0MjNjMTU1YjQ4ODI2NTQ1MzZjNDNiMGRhNjY2NTllMTc4NTBlZGMzYTllNDdlNzAyMGZkY2RhY2VjMzQzY2EyZjFkZWQ4ZWM0MzUwODc5NTllMmEwYTBiOTdhMGQ5ODc5N2Q5MGQ2ZTdhNWZlMzNhODBkNjA3NGI4ZmVmNWYiLCJwIjoiZmY2MDA0ODNkYjZhYmZjNWI0NWVhYjc4NTk0YjM1MzNkNTUwZDlmMWJmMmE5OTJhN2E4ZGFhNmRjMzRmODA0NWFkNGU2ZTBjNDI5ZDMzNGVlZWFhZWZkN2UyM2Q0ODEwYmUwMGU0Y2MxNDkyY2JhMzI1YmE4MWZmMmQ1YTViMzA1YThkMTdlYjNiZjRhMDZhMzQ5ZDM5MmUwMGQzMjk3NDRhNTE3OTM4MDM0NGU4MmExOGM0NzkzMzQzOGY4OTFlMjJhZWVmODEyZDY5YzhmNzVlMzI2Y2I3MGVhMDAwYzNmNzc2ZGZkYmQ2MDQ2MzhjMmVmNzE3ZmMyNmQwMmUxNyIsInEiOiJlMjFlMDRmOTExZDFlZDc5OTEwMDhlY2FhYjNiZjc3NTk4NDMwOWMzIiwiZyI6ImM1MmE0YTBmZjNiN2U2MWZkZjE4NjdjZTg0MTM4MzY5YTYxNTRmNGFmYTkyOTY2ZTNjODI3ZTI1Y2ZhNmNmNTA4YjkwZTVkZTQxOWUxMzM3ZTA3YTJlOWUyYTNjZDVkZWE3MDRkMTc1ZjhlYmY2YWYzOTdkNjllMTEwYjk2YWZiMTdjN2EwMzI1OTMyOWU0ODI5YjBkMDNiYmM3ODk2YjE1YjRhZGU1M2UxMzA4NThjYzM0ZDk2MjY5YWE4OTA0MWY0MDkxMzZjNzI0MmEzODg5NWM5ZDViY2NhZDRmMzg5YWYxZDdhNGJkMTM5OGJkMDcyZGZmYTg5NjIzMzM5N2EifSwicHJpbmNpcGFsIjp7ImVtYWlsIjoicnNleXNAbW96aWxsYS5jb20ifSwiaWF0IjoxMzcxNjg0NDA3NjA5LCJleHAiOjEzNzE2ODgwMDc2MDksImlzcyI6IjEyNy4wLjAuMSJ9.OovdL4L8gPJ5vd6hh1N8VBOLdVYOOPkueJNKMelsRvABrRGvi4BVWR4LZJjYjUCTB0he0fybyNBAAg7kKI8BjlBjKM26VP9ioNx-Cqt6ADNGyPxnoTkhjUCABkQ68fpgBSF7JHY1bGa1P0izppRIZh0LSxUlLXDo8HBwKvqL99ZgC3u-gOSjDEEEBZq9tTekLBD6Hg451Zlev8sh3FQok6VhB6I6iKqKfre4_WPXS9nDp-0lj0YzQg26e9WJhY32YcgHj4Sz-OzAP3JwvGHKcrvk9kPST2Nz1A5ouhpNbFXhuQKy1b1M9Xk2FeIsp7qXAT0fGxy0jjS4QBJsVeEzQg~eyJhbGciOiJEUzEyOCJ9.eyJleHAiOjEzNzE2ODY4NDM4NTksImF1ZCI6InJ0Y3dlYjovL3BlZXJjb25uZWN0aW9uIn0.RA9o8QyOTxuzItjy-o92ZQPEzVJu9eMxloD83IgZH0K8DKHHxtPVuw";
+
+function test_import() {
+  do_check_eq(typeof IDPChannel, "function");
+  do_check_eq(typeof Pipe, "function");
+  do_check_eq(typeof HostFrame, "function");
+  do_check_eq(typeof unpackAssertion, "function");
+  run_next_test();
+}
+
+function test_unpackAssertion() {
+  let unpacked = unpackAssertion(ASSERTION);
+  do_check_eq(unpacked.assertion.aud, "rtcweb://peerconnection");
+  run_next_test();
+}
+
+function test_ready() {
+  do_test_pending();
+
+  let onMessage = function onMessage(message) {
+    do_check_eq(message.type, "READY");
+    do_test_finished();
+    run_next_test();
+  }
+
+  let channel = new IDPChannel(onMessage);
+}
+
+function test_sign() {
+  do_test_pending();
+  let sign_message = {
+    type: "SIGN",
+    id: 1,
+    origin: "https://calling-service.example.com/",
+    message: "abcdefghijklmnopqrstuvwyz"
+  };
+
+  let onMessage = function onMessage(message) {
+    switch(message.type) {
+      case "READY":
+        // wait until the next tick so channel will not be undefined
+        do_timeout(0, function sendSignMessage() {
+          channel.send(sign_message);
+        });
+        break;
+      case "SUCCESS":
+        do_check_eq(message.id, sign_message.id);
+        do_check_eq(message.message.assertion, MOCK_ASSERTION);
+        do_test_finished();
+        run_next_test();
+        break;
+      default:
+        do_throw("Weird message type: " + message.type);
+        break;
+    }
+  };
+  let channel = new IDPChannel(onMessage, {
+    PipeConstructor: MockPipe, 
+    HostFrameConstructor: MockHostFrame
+  });
+}
+
+function test_verify() {
+  do_test_pending();
+  let verify_message = {
+    type: "VERIFY",
+    id: 2,
+    origin: "https://calling-service.example.com/",
+    message: MOCK_ASSERTION
+  };
+
+  let server = new HttpServer();
+  server.registerPathHandler('/verify', function(data, response) {
+    var verifierResponse = JSON.stringify({
+      status: "okay",
+      email: USER_IDENTITY,
+      audience: "rtcweb://peerconnection"
+    });
+
+    response.processAsync();
+    response.setStatusLine("1.0", 200, "OK");
+    response.setHeader("Cache-Control", "no-cache", false);
+    response.setHeader("Content-Type", "aplication/json", false);
+    do_timeout(0, function() {
+      response.write(verifierResponse);
+      response.finish();
+    });
+  });
+  server.start(8080);
+
+  let onMessage = function onMessage(message) {
+    switch(message.type) {
+      case "READY":
+        // wait until the next tick so channel will not be undefined
+        do_timeout(0, function sendSignMessage() {
+          channel.send(verify_message);
+        });
+        break;
+      case "SUCCESS":
+        do_check_eq(message.id, verify_message.id);
+        do_check_eq(message.message.identity.name, USER_IDENTITY);
+        // XXX once verifier can unpack assertion
+        //do_check_eq(message.message.contents, FINGERPRINT);
+        do_test_finished();
+        run_next_test();
+        break;
+      default:
+        do_throw("Weird message type: " + message.type);
+        break;
+    }
+  };
+  let channel = new IDPChannel(onMessage, {
+    PipeConstructor: MockPipe, 
+    HostFrameConstructor: MockHostFrame,
+    verifierUri: "http://localhost:8080/verify"
+  });
+}
+
+function MockHostFrame() { }
+MockHostFrame.prototype = {
+  getIframe: function getIframe(aOptions, aCallback) {
+    aCallback(null);
+  }
+};
+
+function MockPipe(aOptions, aController) { 
+  this.options = aOptions;
+  this.controller = aController;
+}
+MockPipe.prototype = {
+  close: function close() {},
+  communicate: function communicate() {
+    // here's where we would send our one async message (sign) 
+    // to the hosted persona iframe.  The iframe would send a
+    // certificate-backed assertion back to us in response, which
+    // we relay to the controller
+    let message = this.options.message;
+    this.controller.receiveResponse({
+      type: "SUCCESS",
+      id: message.id,
+      message: {
+        assertion: MOCK_ASSERTION
+      }
+    });
+  }
+};
+
+/*
+ * utilities
+ */
+
+function mockPeerConnection(aFingerprint, aFunction) {
+  let mock = {};
+  mock.fingerprint = aFingerprint;
+  mock.signalingState = "open";
+  mock['do'] = aFunction;
+  mock.onidentityresult = partial(aFunction, 'onidentityresult');
+
+  return mock;
+}
+
+/*
+ * add tests to suite and run them
+ */
+
+let TESTS = [ 
+  test_import,
+  test_unpackAssertion,
+  test_ready,
+  test_sign,
+  test_verify
+];
+
+TESTS.forEach(add_test);
+
+function run_test() {
+  run_next_test();
+}
+
+
diff --git a/toolkit/identity/tests/unit/xpcshell.ini b/toolkit/identity/tests/unit/xpcshell.ini
--- a/toolkit/identity/tests/unit/xpcshell.ini
+++ b/toolkit/identity/tests/unit/xpcshell.ini
@@ -1,16 +1,17 @@
 [DEFAULT]
 head = head_identity.js
 tail = tail_identity.js
 
 # Test load modules first so syntax failures are caught early.
 [test_load_modules.js]
 [test_minimalidentity.js]
 
+[test_rtcauthmodule.js]
 [test_identity_utils.js]
 [test_log_utils.js]
 [test_authentication.js]
 [test_crypto_service.js]
 [test_identity.js]
 [test_jwcrypto.js]
 [test_observer_topics.js]
 [test_provisioning.js]
